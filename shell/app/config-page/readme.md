## 组件化协议

### 理念

前端提供组件和配置模板，模板中按前端所需格式定义数据和操作。
后端按模板提供前端所需数据，在用户交互时，发送上下文信息给后端，后端返回新的数据。

优点：

- 前端可以专注于自己想要的数据格式，不用对接和维护后端接口
- 前端可以专注于交互和设计优化，屏蔽变化的业务属性，减少前端的改动
- 所有页面数据可以在一个接口返回，避免前端多次调用接口和拼凑数据的复杂逻辑
- 减少前端人力投入，将逻辑处理放到后端，避免前端资源瓶颈

### 文件结构规范

#### components 目录

定义所有组件，每个组件应当放在自己的文件夹中，除了组件文件外，还应包含细致的类型定义(必须以 spec.d.ts 结尾)和 mock 数据。
例如 `table` 组件：

```
components
  - table
    - table.tsx
    - table.scss
    - table.spec.d.ts
    - table.mock.ts
```

#### docs 目录

使用 `npm run gen-cp-md` 命令，通过 components 目录下所有的 d.ts 文件，生成的对应 markdown 文档，用于持续更新维护。
提供给后端的，也是这份文档，其他地方的如果不能生成的文档，也放在此处维护（需要考虑如何对外分享）。

### 注意事项

- 所有 ts、tsx 文件应当只有一个默认导出
- 组件文件名为小写中横线连接，组件目录和文件名保持一致
- 组件文件内的名称，使用 `CP_` 作为前缀，例如 `const CP_Table = ...`，
- 类型定义文件使用 `spec.d.ts` 后缀，如果和组件名同名，会导致 d.ts 文件内无法正确 resolve 全局的 type 定义
- spec 中的 `Props` 类型使用 MakeProps 方法生成，会添加框架附带的一些 props 给组件。 `type Props = MakeProps<Spec>;`
- mock 数据使用 `MockSpec<T>` 包装一下，例如 `MockSpec<CP_COMP.Spec>` 类型，应尽量提供不同配置下的多种数据
- 组件定义更新后，及时生成最新文档
